######################################
- 2 maneras de usar el modulo:
	* tradicional
	* segura

- Forma tradicional
	* problema: alguien, en algun punto de la comunicacion entre las dos puntas está viendo el trafico, lo que normalmente se conoce como "sniffing"
	[mostrar ejemplo]
    	$ tcpdump -i lo -n -p tcp

- Forma "Segura"
	* No se debe poder interpretar con alguien sniffeando
	* 1 solo paquete UDP -> secreto en el payload
	* 1ra aprox: hmac(ipsrc, secreto)
		- impersonation: alguien viene luego de que nos desconectamos
	* 2da aprox: hmac(ipsrc, secreto, epoch_min)
	* sync clock
	* antireplay -> "un knock por IP por minuto" (evito ser impersonado)
	$ tcpdump -i lo -n -p udp -w packets.dump

- Que no Resuelve:
	* Man in the Middle (lack of association).
	* integridad y confidencialidad de la conexión
    	* solucion: VPN

- Userspace -> Kernel
	* separacion de intereses
	* utilidad: escasos recursos quizas => levanto y bajo apache

- Testing
	* scripts ejecucion
	
######################################

######################################
TODO:
- mostrar el problema de NAT
- estudiar netlink socket
- conclusion!
######################################




[LUCHO]
- Cuestiones de la 1ra aproximación:

    {todo muy lindo, pero vimos que era necesario agregar algo de seguridad al mecanismo tradicional, imaginemos esta posibilidad:}
    
    Asumimos que un adversario podría:

    * Ver (sniffear) el trafico de red.
    
    * nuestro problema: con solo hacer replay desde otra IPsrc estaría abriendo el puerto.
    
    {y todo se vendria abajo... :(}
    
- 2da Aproximación:

	* autenticamos con el payload en un solo msj UDP
	* payload: hmac(ipsrc, password)
    {ahora nuestro secreto cambia de ser la secuencia de puertos a un password que se incluira en el hmac}
    * ¿que es un hmac?
    {mac: message authentication code -> código de autenticación de mensajes, para garantizar autenticidad e integridad, se necesita de una clave simetrica.
    hmac: mac usando hash functions y aplicando algunas operaciones XOR y de concatenacion con valores ctes.
    hash: fcs "one-way", sabiendo la salida de la fc no me permite saber la entrada, es muy dificil "volver para atras"
    diff entre hash y hmacs: a MAC may be considered secure even if the key-holder can efficiently find collisions.
    }
    
	* no pueden abrir el servicio desde otra ipsrc
    {con saber el hmac del knock de una IP no me permite saber el secreto y por ende no puedo generar un nuevo hmac que sea valido desde otra IP}
    * podrian al repetir el msj, abrir la puerta a otra IP.
    {o lo que es peor...}
    

- ...problema:

	* roban nuestra identidad (impersonation, suplantación ó spoofing de nuestra IP), podrian repetir el knock. {por ejemplo, luego que termino mi conexion, viene otro atrás y toma mi identidad con un ataque ARP spoof}
	{Es un riesgo latente que puede ocurrir}
    
	
- 3ra Aproximación:

    * ¿Como logro evitar cualquier tipo de replay?
    * solucion: ISO 9798-4 one-pass unilateral authentication with hmac and timestamps:
	* hmac(ipsrc, secreto, epoch_min)
	{epoch_min is the minute since 1st january 1970}
	* validez de un solo minuto
    * clock sync {rdate para setear el reloj del sistema segun UTC (tiempo universal coordinado), luego hay que setear el del hardware}
	* no acepto repeticion dentro de ese minuto
	* esto soluciona el siguiente escenario:
		- open knock
		- conexion
		- close knock
		- dentro del mismo minuto alguien roba mi identidad y quiere replicar el paquete.
	* "un knock por IP por minuto"


- Portknocking no es una solución a:

	* Man in the Middle, con capacidad de suprimir trafico, podria dejar pasar el open knock, luego bloquear nuestro trafico y tomar nuestra identidad. El problema es que en portknocking no hay una asociación entre autenticacion y conexion.
	* integridad y confidencialidad de la conexión
    * solucion: VPN


- Utilidad del userspace message.

	* Arquitectura de otras implementaciones de port knocking (asíncrono)
	* Nuestra arquitectura (síncrono) -> mas efectiva.
	* mensajes kernelspace -> userspace : RULE_NAME + Peer IP 
    * separacion de intereses.
	{el kernel se encarga de reconocer aquellos que concretaron una sequencia valida de knocks y la aplicacion se encarga de disparar una accion}

[LUCHO]
	* mini-framework para testing
	{
	
	situacion: fede hizo lo 1ro, y yo lo continue...
	cuestión: en cada cambio al módulo, ¿como me aseguro que no rompi nada?
	pruebas manuales: todo mal, consumen tiempo, repetitivas, con el paso del tiempo me cansaria y no las haría. ej:
	
	ssh user@localhost # no me debe dejar entrar
	ssh user@localhost -p 2003
	ssh user@localhost -p 2001
	ssh user@localhost -p 2005
	ssh user@localhost # debo poder entrar
	
	solucion: pruebas automatizadas!!!!!!!!!!
	
	posibilidad de "ejecutar" una especificacion del modulo, un caso de uso, un escenario:
	
	01.test:
	
	#####
	load
	expect "register"
	
	knock_udp "10.10.0.1" "22"
	expect "!PASS OK"
	knock_udp "10.10.0.1" "2000"
	expect "MATCHING"
	knock_udp "10.10.0.1" "2001"
	expect "ALLOWED"
	knock_udp "10.10.0.1" "22"
	expect "PASS OK"
	#####
	
	Era complicado probar en kernel, no hay frameworks para hacer pruebas unitarias, entonces gracias a facilidades de loggear partes ejecutadas del código + hping para generar paquetes + una combinacion de shell scripting & python:
	
	./testrunner.sh 01.test
	.....
	5 tests
	PASS OK!
	
	actualmente:
	
	./testrunner.sh all.test
	...................................................................
	67 tests
	PASS OK!
	
	de esta manera se tenia confianza y agilidad para realizar cambios
	
	}
	
	

