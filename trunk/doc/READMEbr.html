<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 7.1.2" />
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
}

strong {
  font-weight: bold;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1 {
  border-bottom: 2px solid silver;
}
h2 {
  border-bottom: 2px solid silver;
  padding-top: 0.5em;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.2em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble,
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-right: 10%;
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock > div.content {
  padding-left: 2.0em;
}

div.attribution {
  text-align: right;
}
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.verseblock div.content {
  white-space: pre;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: italic;
}
dd > *:first-child {
  margin-top: 0;
}

ul, ol {
    list-style-position: outside;
}
ol.olist2 {
  list-style-type: lower-alpha;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}

div.hlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
td.hlist1 {
  vertical-align: top;
  font-style: italic;
  padding-right: 0.8em;
}
td.hlist2 {
  vertical-align: top;
}

@media print {
  div#footer-badges { display: none; }
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-content {
  padding-left: 2.0em;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}
</style>
<title>PROJECTO PORTKNOCKO</title>
</head>
<body>
<div id="header">
<h1>PROJECTO PORTKNOCKO</h1>
</div>
<div id="preamble">
<div class="sectionbody">
<p>O projeto de PortKnocko é composto de duas porções: um módulo do iptables (espaço do usuário) e um
módulo do netfilter (espaço da kernel). O primeiro é uma extensão do iptables, e o segundo é uma
extensão do netfilter.</p>
<p>Ambos módulos são usados para executar Port Knocking, um sistema sigiloso para o autenticação da
rede através dos portos fechados, e o SPA (Simple Packet Authentication). Por exemplo, isto pode
ser usado para evitar ataques da força brute ao ssh ou aos serviços do ftp.</p>
</div>
</div>
<h2>INSTALAÇÃO</h2>
<div class="sectionbody">
<p>Acesso Anonymous ao repositorio através de SVN:</p>
<div class="listingblock">
<div class="content">
<pre><tt>svn checkout svn://svn.berlios.de/portknocko/trunk</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt># cd portknocko
# ~/portknocko/cd iptables
# ~/portknocko/iptables/make clean
# ~/portknocko/iptables/make
# ~/portknocko/iptables/make install

# cd ../kernel
# ~/portknocko/kernel/make clean
# ~/portknocko/kernel/make
# ~/portknocko/kernel/make install

# depmod -Ae</tt></pre>
</div></div>
<p>NOTA: se você usa: “insmod ./ipt_pknock.ko”, primeiramente você teria que fazer “modprobe cn”
para carregar o conector do netlink.</p>
</div>
<h2>USO:</h2>
<div class="sectionbody">
<p>Nós mostraremos os usos possíveis deste módulo:</p>
<h3>1) “a maneira mais simple”, portknocking de uma régua:</h3>
<div class="listingblock">
<div class="content">
<pre><tt># iptables -P INPUT DROP
# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# iptables -A INPUT -p tcp -m state --state NEW
        -m pknock --knockports 2002,2001,2004 --name SSH
        -m tcp --dport 22 -j ACCEPT</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ telnet yourserver 2002 # first knock
$ telnet yourserver 2001
$ telnet yourserver 2004 # last knock

$ ssh user@yourserver</tt></pre>
</div></div>
<p>NOTA: Todos os “knocks” e tráfego devem ser pacotes do TCP.</p>
</div>
<h2>opções:</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre><tt>[--time seconds]        -&gt; tempo máximo entre knocks.
[--strict]              -&gt; se falha um knock do peer quando tenta
                        uma seqüência do portos, deve começar outra
                        vez.</tt></pre>
</div></div>
<h3>2) “a maneira SPA”, autenticação hmac com dois réguas do iptables:</h3>
<p>Com este você pode conseguir evitar o replicação e spoofing dos pacotes.</p>
<div class="listingblock">
<div class="content">
<pre><tt># iptables -P INPUT DROP
# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# iptables -A INPUT -p udp -m state --state NEW
        -m pknock --knockports 2000 --name SSH
        --opensecret your_opensecret --closesecret your_closesecret
        -j DROP
# iptables -A INPUT -p tcp -m state --state NEW
        -m pknock --checkip --name SSH -m tcp --dport 22 -j ACCEPT</tt></pre>
</div></div>
<p>Para esta maneira você deve emitir pacotes UDP, cujo payload contem um “sha256
hmac digest “:</p>
<div class="literalblock">
<div class="content">
<pre><tt>sha256_mac(your_opensecret, your_ip, epoch_min)</tt></pre>
</div></div>
<p>NOTA: “epoch_min” são os minutos desde janeiro 1º 1970, assim que você deve
manter sincronizado os relógios do servidor e de seu host. Para sincronizar os
relógios, você pode fazer a seguinte coisa:</p>
<p>Depois que os knocks são aceitados, você pode começar o tráfego do TCP através
do porto 22. Quando você termina, fecha a porta (ver o exemplo abaixo) para
evitar que aqueles que usam seu mesmo IP possam usar o serviço ssh.</p>
<p>Nós fornecemos um cliente para fazer o knocking da maneira SPA:</p>
<div class="listingblock">
<div class="content">
<pre><tt># rdate time-a.nist.gov         # this will set your system clock
# /sbin/hwclock --systohc --utc # this will set your hardware clock to UTC</tt></pre>
</div></div>
<p>Luego de que el "knock" es aceptado, puedes comenzar el tráfico TCP através
del puerto 22. Cuando termines, cierra la puerta (ver ejemplo abajo) para evitar
que los que usen tu misma ip puedan utilizar el servicio ssh.</p>
<p>Nosotros proveemos un cliente para hacer el knocking de la forma SPA:</p>
<div class="listingblock">
<div class="content">
<pre><tt># cd test
# util/knock.sh &lt;IP src&gt; &lt;PORT dst&gt; &lt;secret&gt; &lt;IP dst&gt;</tt></pre>
</div></div>
<p>NOTA: Você deve ter instalado o pacote python-crypto.</p>
<p>exemplo:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/util/knock.sh 192.168.0.1 2000 your_opensecret</tt></pre>
</div></div>
<p>Depois que você termina usar o serviço você teria “fechar a porta”:</p>
<p>exemplo:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/util/knock.sh 192.168.0.1 2000 your_closesecret</tt></pre>
</div></div>
<p>NOTA: Recorda que estas são contra-senhas somente do uso único, assim que
você não pode usar o mesmo hmac. Você somente pode emitir um pacote (com o
segredo) por minuto. Depois desse minuto, hmac expira. Dentro desse tempo,
o módulo aceitará só um único pacote com o mesmo secreto. Se fosse tentado
replicar este pacote, o módulo rejeitá-lo-ia.</p>
<p>Caso que você está sendo NATado, substitui somente &lt;IP src&gt; pela IP pública.</p>
<p>O protocolo da segurança usado neste módulo é baseado em uma implementação do espaço do usuário chamada Tumbler: http://tumbler.sourceforge.net/</p>
</div>
<h2>COMUNICAÇÃO COM O ESPAÇO DO USUÁRIO:</h2>
<div class="sectionbody">
<p>Em outras implementações do port knocking, existe um servidor que procure periódicamente nos
registros do firewall a seqüência correta de portos golpeados (knocks). Quando a encontra,
servidor cría réguas novas dos iptables.</p>
<p>Uma alternativa muito boa seria se o servidor somente escutasse e recebesse uma mensagem,
quando alguém está interessado em algo.</p>
<p>Pelos sockets netlink, uma mensagem de um módulo do kernel pode ser emitido a uma aplicação
do espaço do usario, sempre que um peer (ou host) golpeia a seqüência correta dos portos.</p>
<p>Assim você poderia ter um servidor (no espaço do usuário) que espera conexãos e quando alguém
golpeia os portos específicos, o servidor pode receber uma mensagem do módulo do kernel
permitiendo fazer algo. Por ex: você poderia iniciar um web server, aderir ao peer (ou ao
host) a uma lista, etc. Alguma coisa em uma maneira eficiente.</p>
<p>Step-by-step:</p>
<p>1) Compila o módulo.
2) Carrega o módulo: insmod ./ipt_pknock.ko nl_multicast_group=&lt;value&gt;
3) Inicía o servidor. Existe uma implementação mínima no diretório que mostra a uma mensagem
sempre que alguém golpeia a seqüência dos portos.</p>
</div>
<h2>TESTES: (ter cuidado, isto apagará suas réguas dos iptables que você carregou)</h2>
<div class="sectionbody">
<p>Se você é um programador, após ter modificado o código do módulo você pode executar estes
testes:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/portknocko/cd test
# ~/portknocko/test/./testrunner.sh all.test</tt></pre>
</div></div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 10-Jun-2007 14:15:51 ART
</div>
</div>
</body>
</html>
