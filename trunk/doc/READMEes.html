<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 7.1.2" />
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
}

strong {
  font-weight: bold;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1 {
  border-bottom: 2px solid silver;
}
h2 {
  border-bottom: 2px solid silver;
  padding-top: 0.5em;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.2em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble,
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-right: 10%;
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock > div.content {
  padding-left: 2.0em;
}

div.attribution {
  text-align: right;
}
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.verseblock div.content {
  white-space: pre;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: italic;
}
dd > *:first-child {
  margin-top: 0;
}

ul, ol {
    list-style-position: outside;
}
ol.olist2 {
  list-style-type: lower-alpha;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}

div.hlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
td.hlist1 {
  vertical-align: top;
  font-style: italic;
  padding-right: 0.8em;
}
td.hlist2 {
  vertical-align: top;
}

@media print {
  div#footer-badges { display: none; }
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-content {
  padding-left: 2.0em;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}
</style>
<title>PROYECTO PORTKNOCKO</title>
</head>
<body>
<div id="header">
<h1>PROYECTO PORTKNOCKO</h1>
</div>
<div id="preamble">
<div class="sectionbody">
<p>El proyecto PortKnockO está compuesto de dos partes: un módulo iptables
(espacio de usuario) y un módulo netfilter (espacio de kernel). El
primero es una extensión de iptables, mientras que el segundo es una
extensión de netfilter.</p>
<p>Ambos módulos implementan Port Knocking, un sistema sigiloso para la
autenticación a través de puertos cerrados. Por ejemplo, esto podría ser
usado para evitar ataques por fuerza bruta a servicios como ssh o ftp.</p>
<p>Estos módulos también implementan SPA (Simple Packet Authentication).</p>
</div>
</div>
<h2>INSTALACIÓN</h2>
<div class="sectionbody">
<p>Acceso anónimo al repositorio via SVN:</p>
<div class="listingblock">
<div class="content">
<pre><tt>svn checkout svn://svn.berlios.de/portknocko/trunk</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt># cd portknocko
# ~/portknocko/cd iptables
# ~/portknocko/iptables/make clean
# ~/portknocko/iptables/make
# ~/portknocko/iptables/make install

# cd ../kernel
# ~/portknocko/kernel/make clean
# ~/portknocko/kernel/make
# ~/portknocko/kernel/make install

# depmod -Ae</tt></pre>
</div></div>
<p>NOTA: si usas: "insmod ./ipt_pknock.ko", primero deberías hacer "modprobe cn"
para cargar el conector netlink.</p>
</div>
<h2>USO:</h2>
<div class="sectionbody">
<p>Mostraremos los posibles usos de este módulo:</p>
<h3>1) "la forma más simple", una sola regla para implementar portknocking:</h3>
<div class="listingblock">
<div class="content">
<pre><tt># iptables -P INPUT DROP
# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# iptables -A INPUT -p tcp -m state --state NEW
        -m pknock --knockports 2002,2001,2004 --name SSH
        -m tcp --dport 22 -j ACCEPT</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ telnet yourserver 2002 # first knock
$ telnet yourserver 2001
$ telnet yourserver 2004 # last knock

$ ssh user@yourserver</tt></pre>
</div></div>
<p>NOTA: Todos los "knocks" y el tráfico deben ser paquetes TCP.</p>
</div>
<h2>opciones:</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre><tt>[--time seconds]        -&gt; máximo tiempo entre "knocks" (golpes).
[--strict]              -&gt; si uno de los "knocks" del peer falla al
                        intentar la secuencia de puertos, debe
                        comenzar de nuevo.</tt></pre>
</div></div>
<h3>2) "la forma SPA", autenticación hmac con dos reglas de iptables:</h3>
<p>Con esto puedes lograr evitar la replicación y el spoofing de paquetes.</p>
<div class="listingblock">
<div class="content">
<pre><tt># iptables -P INPUT DROP
# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# iptables -A INPUT -p udp -m state --state NEW
        -m pknock --knockports 2000 --name SSH
        --opensecret your_opensecret --closesecret your_closesecret
        -j DROP
# iptables -A INPUT -p tcp -m state --state NEW
        -m pknock --checkip --name SSH -m tcp --dport 22 -j ACCEPT</tt></pre>
</div></div>
<p>Para esta forma debes enviar paquetes UDP, cuyo payload contenga un "sha256 hmac
digest":</p>
<div class="literalblock">
<div class="content">
<pre><tt>sha256_mac(your_opensecret, your_ip, epoch_min)</tt></pre>
</div></div>
<p>NOTA: "epoch_min" son los minutos desde el 1ro de Enero de 1970, por lo que
debes mantener sincronizados el reloj del servidor y el de tu host. Para
sincronizar los relojes, puedes hacer lo siguiente:</p>
<div class="listingblock">
<div class="content">
<pre><tt># rdate time-a.nist.gov         # this will set your system clock
# /sbin/hwclock --systohc --utc # this will set your hardware clock to UTC</tt></pre>
</div></div>
<p>Luego de que el "knock" es aceptado, puedes comenzar el tráfico TCP através
del puerto 22. Cuando termines, cierra la puerta (ver ejemplo abajo) para evitar
que los que usen tu misma ip, puedan utilizar el servicio ssh.</p>
<p>Nosotros proveemos un cliente para hacer el knocking de la forma SPA:</p>
<div class="listingblock">
<div class="content">
<pre><tt># cd test
# util/knock.sh &lt;IP src&gt; &lt;PORT dst&gt; &lt;secret&gt; &lt;IP dst&gt;</tt></pre>
</div></div>
<p>NOTA: Debes tener instalado el paquete python-crypto.</p>
<p>ej:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/util/knock.sh 192.168.0.1 2000 your_opensecret</tt></pre>
</div></div>
<p>Luego de que termines de usar el servicio, deberías "cerrar la puerta":</p>
<p>ej:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/util/knock.sh 192.168.0.1 2000 your_closesecret</tt></pre>
</div></div>
<p>NOTA: Recuerda que estas son contraseñas de único uso, por lo que no se
puede reutilizar el mismo hmac. Sólo puedes enviar un paquete (con el
secreto) por minuto. Luego de ese minuto, el hmac expira. Dentro de esa
ventana de tiempo, el módulo aceptará solo un paquete con el mismo
secreto. Si se intentara replicar este paquete, el módulo lo rechazaría.</p>
<p>En caso de que estés siendo NATeado, sólo reemplaza &lt;IP src&gt; por la IP pública.</p>
<p>El protocolo de seguridad utilizado en este módulo, está basado en una implementación
de espacio de usuario llamada Tumbler: http://tumbler.sourceforge.net/</p>
</div>
<h2>COMUNICACIÓN CON EL ESPACIO DE USUARIO:</h2>
<div class="sectionbody">
<p>En otras implementaciones de port knocking, existe un servidor que periódicamente
busca en los logs del firewall la secuencia correcta de puertos golpeados (knocks).
Cuando éste la encuentra, el servidor crea nuevas reglas iptables.</p>
<p>Una muy buena alternativa sería si el servidor sólo escuchara y recibiera un mensaje,
cuando alguien está interesado en algo. Si esto fuera posible, seguramente
simplificaría la arquitectura del servidor y la haría más eficiente.</p>
<p>Gracias a los sockets netlink, un mensaje desde un módulo de kernel puede ser enviado
a una aplicación de espacio de usario, cada vez que un peer (o host) golpea la
secuencia correcta de puertos.</p>
<p>De esta manera, podrías tener un servidor (en espacio de usuario) esperando
conexiones y cuando alguien golpee los puertos específicos, el servidor puede
recibir un mensaje desde el módulo de kernel permitiéndote hacer algo. Por ej: podrías
iniciar un servidor web, adherir un peer (o host) a una lista blanca, etc. Cualquier
cosa en una manera eficiente.</p>
<p>Paso a paso:</p>
<p>1) Compila el módulo.
2) Carga el módulo: insmod ./ipt_pknock.ko nl_multicast_group=&lt;value&gt;
3) Inicia el servidor. Hay una implementación mínima en el directorio
experiments/netlink_broadcast que muestra un mensaje cada vez que alguien golpea
la secuencia de puertos.</p>
</div>
<h2>PRUEBAS: (ten cuidado, esto borrará las reglas iptables que tengas cargadas)</h2>
<div class="sectionbody">
<p>Si eres desarrollador, luego de modificar el código del módulo puedes correr
estos test:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/portknocko/cd test
# ~/portknocko/test/./testrunner.sh all.test</tt></pre>
</div></div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 10-Jun-2007 19:24:10 ART
</div>
</div>
</body>
</html>
