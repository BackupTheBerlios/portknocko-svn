<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 7.1.2" />
<style type="text/css">
/* Debug borders */
p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 {
/*
  border: 1px solid red;
*/
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
}

strong {
  font-weight: bold;
}

tt {
  color: navy;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  font-family: sans-serif;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1 {
  border-bottom: 2px solid silver;
}
h2 {
  border-bottom: 2px solid silver;
  padding-top: 0.5em;
}

div.sectionbody {
  font-family: serif;
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

pre {
  padding: 0;
  margin: 0;
}

span#author {
  color: #527bbd;
  font-family: sans-serif;
  font-weight: bold;
  font-size: 1.2em;
}
span#email {
}
span#revision {
  font-family: sans-serif;
}

div#footer {
  font-family: sans-serif;
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
div#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
div#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

div#preamble,
div.tableblock, div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-right: 10%;
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.5em;
  margin-bottom: 2.5em;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  font-family: sans-serif;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock > div.content {
  padding-left: 2.0em;
}

div.attribution {
  text-align: right;
}
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 2px solid silver;
}

div.exampleblock > div.content {
  border-left: 2px solid silver;
  padding: 0.5em;
}

div.verseblock div.content {
  white-space: pre;
}

div.imageblock div.content { padding-left: 0; }
div.imageblock img { border: 1px solid silver; }
span.image img { border-style: none; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: italic;
}
dd > *:first-child {
  margin-top: 0;
}

ul, ol {
    list-style-position: outside;
}
ol.olist2 {
  list-style-type: lower-alpha;
}

div.tableblock > table {
  border: 3px solid #527bbd;
}
thead {
  font-family: sans-serif;
  font-weight: bold;
}
tfoot {
  font-weight: bold;
}

div.hlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
td.hlist1 {
  vertical-align: top;
  font-style: italic;
  padding-right: 0.8em;
}
td.hlist2 {
  vertical-align: top;
}

@media print {
  div#footer-badges { display: none; }
}
/* Workarounds for IE6's broken and incomplete CSS2. */

div.sidebar-content {
  background: #ffffee;
  border: 1px solid silver;
  padding: 0.5em;
}
div.sidebar-title, div.image-title {
  font-family: sans-serif;
  font-weight: bold;
  margin-top: 0.0em;
  margin-bottom: 0.5em;
}

div.listingblock div.content {
  border: 1px solid silver;
  background: #f4f4f4;
  padding: 0.5em;
}

div.quoteblock-content {
  padding-left: 2.0em;
}

div.exampleblock-content {
  border-left: 2px solid silver;
  padding-left: 0.5em;
}
</style>
<title>PROGETTO PORTKNOCKO</title>
</head>
<body>
<div id="header">
<h1>PROGETTO PORTKNOCKO</h1>
</div>
<div id="preamble">
<div class="sectionbody">
<p>Il progetto PortKnockO si compone di due parti: un modulo iptables (spazio
dell'utente) e un modulo di netfilter (spazio del kernel). Il primo è
un'estensione di iptables, mentre l'altro è un'estensione di netfilter.</p>
<p>Ambedue i moduli sono usati per implementare Port Knocking, un sistema
silenzioso per l'autenticazione attraverso porte chiuse. Per esempio, può
essere usato per evitare gli attacchi di forza bruta contro i servizi come
ssh o ftp.</p>
<p>Questi moduli implementano anche SPA (Simple Packet Authentication).</p>
</div>
</div>
<h2>INSTALLAZIONE</h2>
<div class="sectionbody">
<p>Accesso anonimo al repositorio attraverso SVN:</p>
<div class="listingblock">
<div class="content">
<pre><tt>svn checkout svn://svn.berlios.de/portknocko/trunk</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt># cd portknocko
# ~/portknocko/cd iptables
# ~/portknocko/iptables/make clean
# ~/portknocko/iptables/make
# ~/portknocko/iptables/make install

# cd ../kernel
# ~/portknocko/kernel/make clean
# ~/portknocko/kernel/make
# ~/portknocko/kernel/make install

# depmod -Ae</tt></pre>
</div></div>
<p>NOTA: Se usi: "insmod ./ipt_pknock.ko", in primo luogo dovresti fare
"modprobe cn" per caricare il connettore netlink.</p>
</div>
<h2>USO:</h2>
<div class="sectionbody">
<p>Ti mostreremo diverse possibilità per utilizzare questo modulo:</p>
<h3>1) "il metodo più semplice", una regola per implementare portknocking:</h3>
<div class="listingblock">
<div class="content">
<pre><tt># iptables -P INPUT DROP
# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# iptables -A INPUT -p tcp -m state --state NEW
        -m pknock --knockports 2002,2001,2004 --name SSH
        -m tcp --dport 22 -j ACCEPT</tt></pre>
</div></div>
<div class="listingblock">
<div class="content">
<pre><tt>$ telnet yourserver 2002 # first knock
$ telnet yourserver 2001
$ telnet yourserver 2004 # last knock

$ ssh user@yourserver</tt></pre>
</div></div>
<p>NOTA: Tutti i colpi (knocks) e il traffico devono essere pacchetti TCP.</p>
</div>
<h2>opzioni:</h2>
<div class="sectionbody">
<div class="listingblock">
<div class="content">
<pre><tt>[--time seconds]        -&gt; tempo massimo fra i colpi (knocks).
[--strict]              -&gt; se uno dei colpi (knocks) del peer fallisce
                        durante la sequenza dei porti, devi
                        cominciare di nuovo.</tt></pre>
</div></div>
<h3>2) "il metodo SPA", autenticazione hmac con due regole iptables:</h3>
<p>Con questo puoi evitare la replica e il spoofing dei pacchetti.</p>
<div class="listingblock">
<div class="content">
<pre><tt># iptables -P INPUT DROP
# iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# iptables -A INPUT -p udp -m state --state NEW
        -m pknock --knockports 2000 --name SSH
        --opensecret your_opensecret --closesecret your_closesecret
        -j DROP
# iptables -A INPUT -p tcp -m state --state NEW
        -m pknock --checkip --name SSH -m tcp --dport 22 -j ACCEPT</tt></pre>
</div></div>
<p>Per questo metodo devi trasmettere pacchetti UDP con un payload "sha256
hmac digest":</p>
<div class="literalblock">
<div class="content">
<pre><tt>sha256_mac(your_opensecret, your_ip, epoch_min)</tt></pre>
</div></div>
<p>NOTA: "epoch_min" è il valore dei minuti dal 1 di Gennaio 1970, per questo
devi mantenere sincronizzati gli orologi del server e del tuo computer. Per
arrivare a questo puoi fare quanto segue:</p>
<div class="listingblock">
<div class="content">
<pre><tt># rdate time-a.nist.gov         # questo setterà l'orologio del server
# /sbin/hwclock --systohc --utc # questo setterà l'orologio del tuo computer a UTC</tt></pre>
</div></div>
<p>Dopo che il colpo (knock) è stato accettato, puoi iniziare il traffico TCP
attraverso il porto 22. Quando finisci, chiudi la porta per evitare
che altri che hanno la tua stessa ip, possano utilizzare il servizio ssh.</p>
<p>Ti forniamo un client per fare il knocking del modo SPA:</p>
<div class="listingblock">
<div class="content">
<pre><tt># cd test
# util/knock.sh &lt;IP src&gt; &lt;PORT dst&gt; &lt;secret&gt; &lt;IP dst&gt;</tt></pre>
</div></div>
<p>NOTA: Devi avere installato il pacchetto python-crypto.</p>
<p>per esempio:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/util/knock.sh 192.168.0.1 2000 your_opensecret</tt></pre>
</div></div>
<p>Dopo aver finito di usare il servizio, dovresti "chiudere la porta":</p>
<p>per esempio:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/util/knock.sh 192.168.0.1 2000 your_closesecret</tt></pre>
</div></div>
<p>NOTA: Ricorda che queste sono le parole d'accesso da usare una sola volta,
così che non puoi riutilizzare lo stesso hmac. Puoi spedire un pacchetto
(con il segreto) per minuto, dopodichè lo hmac espira. In questo minuto, il
modulo accetterà un pacchetto con lo stesso segreto. Se si trasmettono
pacchetti con lo stesso segreto, il modulo li respingere.</p>
<p>Nel caso tu sia NATed, sostituisci solo l'indirizzo IP src con lo IP NATed.</p>
<p>Il protocollo di sicurezza usato in questo modulo è basato su un'implementazione
denominata Tumbler: http://tumbler.sourceforge.net/</p>
</div>
<h2>COMUNICAZIONE CON LO SPAZIO DELL'UTENTE:</h2>
<div class="sectionbody">
<p>In altre implementazioni di port knocking, c'è un server che cerca
periodicamente in i logs del firewall per la sequenza corretta dei colpi port.
Quando viene trovata, il server abitualmente crea nuove regole iptables.</p>
<p>Una possibilità grande sarebbe se il server ascoltasse e ricevesse un messaggio,
quando accadesse qualcosa che gli interessa. Se questo fosse possibile, certamente
semplificherebbe l'architettura del server e lo renderebbe più efficiente.</p>
<p>Grazie ai sockets del netlink, un messaggio da questo modulo del kernel viene
trasmesso allo spazio dell'utente ogni volta che un peer colpisce la
sequenza corretta dei porti.</p>
<p>Così per esempio, potresti avere un server che funziona nello spazio dell'utente
e quando qualcuno invia l'opportuna sequenza, il server riceve un messaggio
dal modulo del kernel permettendo fare qualunque cosa. Per esempio: potresti
iniziare un web server, aggiungere un peer a una whilelist, ecc. Tutto in modo
scorrevole ed efficiente.</p>
<p>Passo passo:</p>
<p>1) Compilare il modulo.
2) Carica il modulo: insmod ./ipt_pknock.ko nl_multicast_group=&lt;value&gt;
3) Iniziare il server. C'è un'implementazione minima del server nel
direttorio experiments/netlink_broadcast che stampa un messaggio ogni
volta che qualcuno invia la sequenza corretta.</p>
</div>
<h2>TESTS (fare attenzione, questo cancellerà le regole dei iptables caricate)</h2>
<div class="sectionbody">
<p>Se sei uno sviluppatore, dopo aver modificato il codice del modulo puoi voler
fare funzionare questi tests:</p>
<div class="listingblock">
<div class="content">
<pre><tt># ~/portknocko/cd test
# ~/portknocko/test/./testrunner.sh all.test</tt></pre>
</div></div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 17-Nov-2007 12:15:36 CEST
</div>
</div>
</body>
</html>
