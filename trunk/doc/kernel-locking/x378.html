<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Protecting The Objects Themselves</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Unreliable Guide To Locking"
HREF="index.html"><LINK
REL="UP"
TITLE="Common Examples"
HREF="c328.html"><LINK
REL="PREVIOUS"
TITLE="Exposing Objects Outside This File"
HREF="x354.html"><LINK
REL="NEXT"
TITLE="Common Problems"
HREF="c414.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unreliable Guide To Locking</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x354.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Common Examples</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c414.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="examples-lock-per-obj"
>6.4. Protecting The Objects Themselves</A
></H1
><P
>&#13;In these examples, we assumed that the objects (except the reference
counts) never changed once they are created.  If we wanted to allow
the name to change, there are three possibilities:
    </P
><P
></P
><UL
><LI
><P
>&#13;You can make <CODE
CLASS="symbol"
>cache_lock</CODE
> non-static, and tell people
to grab that lock before changing the name in any object.
        </P
></LI
><LI
><P
>&#13;You can provide a <CODE
CLASS="function"
>cache_obj_rename</CODE
> which grabs
this lock and changes the name for the caller, and tell everyone to
use that function.
        </P
></LI
><LI
><P
>&#13;You can make the <CODE
CLASS="symbol"
>cache_lock</CODE
> protect only the cache
itself, and use another lock to protect the name.
        </P
></LI
></UL
><P
>&#13;Theoretically, you can make the locks as fine-grained as one lock for
every field, for every object.  In practice, the most common variants
are:
</P
><P
></P
><UL
><LI
><P
>&#13;One lock which protects the infrastructure (the <CODE
CLASS="symbol"
>cache</CODE
>
list in this example) and all the objects.  This is what we have done
so far.
	</P
></LI
><LI
><P
>&#13;One lock which protects the infrastructure (including the list
pointers inside the objects), and one lock inside the object which
protects the rest of that object.
        </P
></LI
><LI
><P
>&#13;Multiple locks to protect the infrastructure (eg. one lock per hash
chain), possibly with a separate per-object lock.
        </P
></LI
></UL
><P
>&#13;Here is the "lock-per-object" implementation:
</P
><PRE
CLASS="programlisting"
>&#13;--- cache.c.refcnt-atomic	2003-12-11 15:50:54.000000000 +1100
+++ cache.c.perobjectlock	2003-12-11 17:15:03.000000000 +1100
@@ -6,11 +6,17 @@

 struct object
 {
+        /* These two protected by cache_lock. */
         struct list_head list;
+        int popularity;
+
         atomic_t refcnt;
+
+        /* Doesn't change once created. */
         int id;
+
+        spinlock_t lock; /* Protects the name */
         char name[32];
-        int popularity;
 };

 static spinlock_t cache_lock = SPIN_LOCK_UNLOCKED;
@@ -77,6 +84,7 @@
         obj-&#62;id = id;
         obj-&#62;popularity = 0;
         atomic_set(&#38;obj-&#62;refcnt, 1); /* The cache holds a reference */
+        spin_lock_init(&#38;obj-&#62;lock);

         spin_lock_irqsave(&#38;cache_lock, flags);
         __cache_add(obj);
</PRE
><P
>&#13;Note that I decide that the <CODE
CLASS="structfield"
>popularity</CODE
>
count should be protected by the <CODE
CLASS="symbol"
>cache_lock</CODE
> rather
than the per-object lock: this is because it (like the
<CODE
CLASS="structname"
>struct list_head</CODE
> inside the object) is
logically part of the infrastructure.  This way, I don't need to grab
the lock of every object in <CODE
CLASS="function"
>__cache_add</CODE
> when
seeking the least popular.
</P
><P
>&#13;I also decided that the <CODE
CLASS="structfield"
>id</CODE
> member is
unchangeable, so I don't need to grab each object lock in
<CODE
CLASS="function"
>__cache_find()</CODE
> to examine the
<CODE
CLASS="structfield"
>id</CODE
>: the object lock is only used by a
caller who wants to read or write the <CODE
CLASS="structfield"
>name</CODE
>
field.
</P
><P
>&#13;Note also that I added a comment describing what data was protected by
which locks.  This is extremely important, as it describes the runtime
behavior of the code, and can be hard to gain from just reading.  And
as Alan Cox says, <SPAN
CLASS="QUOTE"
>"Lock data, not code"</SPAN
>.
</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x354.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c414.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Exposing Objects Outside This File</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c328.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Common Problems</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>