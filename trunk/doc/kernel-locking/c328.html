<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Common Examples</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Unreliable Guide To Locking"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Cheat Sheet For Locking"
HREF="c216.html"><LINK
REL="NEXT"
TITLE="Accessing From Interrupt Context"
HREF="x338.html"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unreliable Guide To Locking</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c216.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x338.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="Examples"
></A
>Chapter 6. Common Examples</H1
><P
>&#13;Let's step through a simple example: a cache of number to name
mappings.  The cache keeps a count of how often each of the objects is
used, and when it gets full, throws out the least used one.

    </P
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="examples-usercontext"
>6.1. All In User Context</A
></H1
><P
>&#13;For our first example, we assume that all operations are in user
context (ie. from system calls), so we can sleep.  This means we can
use a semaphore to protect the cache and all the objects within
it.  Here's the code:
    </P
><PRE
CLASS="programlisting"
>&#13;#include &#60;linux/list.h&#62;
#include &#60;linux/slab.h&#62;
#include &#60;linux/string.h&#62;
#include &#60;asm/semaphore.h&#62;
#include &#60;asm/errno.h&#62;

struct object
{
        struct list_head list;
        int id;
        char name[32];
        int popularity;
};

/* Protects the cache, cache_num, and the objects within it */
static DECLARE_MUTEX(cache_lock);
static LIST_HEAD(cache);
static unsigned int cache_num = 0;
#define MAX_CACHE_SIZE 10

/* Must be holding cache_lock */
static struct object *__cache_find(int id)
{
        struct object *i;

        list_for_each_entry(i, &#38;cache, list)
                if (i-&#62;id == id) {
                        i-&#62;popularity++;
                        return i;
                }
        return NULL;
}

/* Must be holding cache_lock */
static void __cache_delete(struct object *obj)
{
        BUG_ON(!obj);
        list_del(&#38;obj-&#62;list);
        kfree(obj);
        cache_num--;
}

/* Must be holding cache_lock */
static void __cache_add(struct object *obj)
{
        list_add(&#38;obj-&#62;list, &#38;cache);
        if (++cache_num &#62; MAX_CACHE_SIZE) {
                struct object *i, *outcast = NULL;
                list_for_each_entry(i, &#38;cache, list) {
                        if (!outcast || i-&#62;popularity &#60; outcast-&#62;popularity)
                                outcast = i;
                }
                __cache_delete(outcast);
        }
}

int cache_add(int id, const char *name)
{
        struct object *obj;

        if ((obj = kmalloc(sizeof(*obj), GFP_KERNEL)) == NULL)
                return -ENOMEM;

        strlcpy(obj-&#62;name, name, sizeof(obj-&#62;name));
        obj-&#62;id = id;
        obj-&#62;popularity = 0;

        down(&#38;cache_lock);
        __cache_add(obj);
        up(&#38;cache_lock);
        return 0;
}

void cache_delete(int id)
{
        down(&#38;cache_lock);
        __cache_delete(__cache_find(id));
        up(&#38;cache_lock);
}

int cache_find(int id, char *name)
{
        struct object *obj;
        int ret = -ENOENT;

        down(&#38;cache_lock);
        obj = __cache_find(id);
        if (obj) {
                ret = 0;
                strcpy(name, obj-&#62;name);
        }
        up(&#38;cache_lock);
        return ret;
}
</PRE
><P
>&#13;Note that we always make sure we have the cache_lock when we add,
delete, or look up the cache: both the cache infrastructure itself and
the contents of the objects are protected by the lock.  In this case
it's easy, since we copy the data for the user, and never let them
access the objects directly.
    </P
><P
>&#13;There is a slight (and common) optimization here: in
<CODE
CLASS="function"
>cache_add</CODE
> we set up the fields of the object
before grabbing the lock.  This is safe, as no-one else can access it
until we put it in cache.
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c216.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x338.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Cheat Sheet For Locking</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Accessing From Interrupt Context</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>