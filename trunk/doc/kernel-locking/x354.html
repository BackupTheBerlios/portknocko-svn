<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Exposing Objects Outside This File</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Unreliable Guide To Locking"
HREF="index.html"><LINK
REL="UP"
TITLE="Common Examples"
HREF="c328.html"><LINK
REL="PREVIOUS"
TITLE="Accessing From Interrupt Context"
HREF="x338.html"><LINK
REL="NEXT"
TITLE="Protecting The Objects Themselves"
HREF="x378.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unreliable Guide To Locking</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x338.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 6. Common Examples</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x378.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="examples-refcnt"
>6.3. Exposing Objects Outside This File</A
></H1
><P
>&#13;If our objects contained more information, it might not be sufficient
to copy the information in and out: other parts of the code might want
to keep pointers to these objects, for example, rather than looking up
the id every time.  This produces two problems.
    </P
><P
>&#13;The first problem is that we use the <CODE
CLASS="symbol"
>cache_lock</CODE
> to
protect objects: we'd need to make this non-static so the rest of the
code can use it.  This makes locking trickier, as it is no longer all
in one place.
    </P
><P
>&#13;The second problem is the lifetime problem: if another structure keeps
a pointer to an object, it presumably expects that pointer to remain
valid.  Unfortunately, this is only guaranteed while you hold the
lock, otherwise someone might call <CODE
CLASS="function"
>cache_delete</CODE
>
and even worse, add another object, re-using the same address.
    </P
><P
>&#13;As there is only one lock, you can't hold it forever: no-one else would
get any work done.
    </P
><P
>&#13;The solution to this problem is to use a reference count: everyone who
has a pointer to the object increases it when they first get the
object, and drops the reference count when they're finished with it.
Whoever drops it to zero knows it is unused, and can actually delete it.
    </P
><P
>&#13;Here is the code:
    </P
><PRE
CLASS="programlisting"
>&#13;--- cache.c.interrupt	2003-12-09 14:25:43.000000000 +1100
+++ cache.c.refcnt	2003-12-09 14:33:05.000000000 +1100
@@ -7,6 +7,7 @@
 struct object
 {
         struct list_head list;
+        unsigned int refcnt;
         int id;
         char name[32];
         int popularity;
@@ -17,6 +18,35 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

+static void __object_put(struct object *obj)
+{
+        if (--obj-&#62;refcnt == 0)
+                kfree(obj);
+}
+
+static void __object_get(struct object *obj)
+{
+        obj-&#62;refcnt++;
+}
+
+void object_put(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&#38;cache_lock, flags);
+        __object_put(obj);
+        spin_unlock_irqrestore(&#38;cache_lock, flags);
+}
+
+void object_get(struct object *obj)
+{
+        unsigned long flags;
+
+        spin_lock_irqsave(&#38;cache_lock, flags);
+        __object_get(obj);
+        spin_unlock_irqrestore(&#38;cache_lock, flags);
+}
+
 /* Must be holding cache_lock */
 static struct object *__cache_find(int id)
 {
@@ -35,6 +65,7 @@
 {
         BUG_ON(!obj);
         list_del(&#38;obj-&#62;list);
+        __object_put(obj);
         cache_num--;
 }

@@ -63,6 +94,7 @@
         strlcpy(obj-&#62;name, name, sizeof(obj-&#62;name));
         obj-&#62;id = id;
         obj-&#62;popularity = 0;
+        obj-&#62;refcnt = 1; /* The cache holds a reference */

         spin_lock_irqsave(&#38;cache_lock, flags);
         __cache_add(obj);
@@ -79,18 +111,15 @@
         spin_unlock_irqrestore(&#38;cache_lock, flags);
 }

-int cache_find(int id, char *name)
+struct object *cache_find(int id)
 {
         struct object *obj;
-        int ret = -ENOENT;
         unsigned long flags;

         spin_lock_irqsave(&#38;cache_lock, flags);
         obj = __cache_find(id);
-        if (obj) {
-                ret = 0;
-                strcpy(name, obj-&#62;name);
-        }
+        if (obj)
+                __object_get(obj);
         spin_unlock_irqrestore(&#38;cache_lock, flags);
-        return ret;
+        return obj;
 }
</PRE
><P
>&#13;We encapsulate the reference counting in the standard 'get' and 'put'
functions.  Now we can return the object itself from
<CODE
CLASS="function"
>cache_find</CODE
> which has the advantage that the user
can now sleep holding the object (eg. to
<CODE
CLASS="function"
>copy_to_user</CODE
> to name to userspace).
</P
><P
>&#13;The other point to note is that I said a reference should be held for
every pointer to the object: thus the reference count is 1 when first
inserted into the cache.  In some versions the framework does not hold
a reference count, but they are more complicated.
</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="examples-refcnt-atomic"
>6.3.1. Using Atomic Operations For The Reference Count</A
></H2
><P
>&#13;In practice, <SPAN
CLASS="type"
>atomic_t</SPAN
> would usually be used for
<CODE
CLASS="structfield"
>refcnt</CODE
>.  There are a number of atomic
operations defined in

<TT
CLASS="filename"
>include/asm/atomic.h</TT
>: these are
guaranteed to be seen atomically from all CPUs in the system, so no
lock is required.  In this case, it is simpler than using spinlocks,
although for anything non-trivial using spinlocks is clearer.  The
<CODE
CLASS="function"
>atomic_inc</CODE
> and
<CODE
CLASS="function"
>atomic_dec_and_test</CODE
> are used instead of the
standard increment and decrement operators, and the lock is no longer
used to protect the reference count itself.
</P
><PRE
CLASS="programlisting"
>&#13;--- cache.c.refcnt	2003-12-09 15:00:35.000000000 +1100
+++ cache.c.refcnt-atomic	2003-12-11 15:49:42.000000000 +1100
@@ -7,7 +7,7 @@
 struct object
 {
         struct list_head list;
-        unsigned int refcnt;
+        atomic_t refcnt;
         int id;
         char name[32];
         int popularity;
@@ -18,33 +18,15 @@
 static unsigned int cache_num = 0;
 #define MAX_CACHE_SIZE 10

-static void __object_put(struct object *obj)
-{
-        if (--obj-&#62;refcnt == 0)
-                kfree(obj);
-}
-
-static void __object_get(struct object *obj)
-{
-        obj-&#62;refcnt++;
-}
-
 void object_put(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&#38;cache_lock, flags);
-        __object_put(obj);
-        spin_unlock_irqrestore(&#38;cache_lock, flags);
+        if (atomic_dec_and_test(&#38;obj-&#62;refcnt))
+                kfree(obj);
 }

 void object_get(struct object *obj)
 {
-        unsigned long flags;
-
-        spin_lock_irqsave(&#38;cache_lock, flags);
-        __object_get(obj);
-        spin_unlock_irqrestore(&#38;cache_lock, flags);
+        atomic_inc(&#38;obj-&#62;refcnt);
 }

 /* Must be holding cache_lock */
@@ -65,7 +47,7 @@
 {
         BUG_ON(!obj);
         list_del(&#38;obj-&#62;list);
-        __object_put(obj);
+        object_put(obj);
         cache_num--;
 }

@@ -94,7 +76,7 @@
         strlcpy(obj-&#62;name, name, sizeof(obj-&#62;name));
         obj-&#62;id = id;
         obj-&#62;popularity = 0;
-        obj-&#62;refcnt = 1; /* The cache holds a reference */
+        atomic_set(&#38;obj-&#62;refcnt, 1); /* The cache holds a reference */

         spin_lock_irqsave(&#38;cache_lock, flags);
         __cache_add(obj);
@@ -119,7 +101,7 @@
         spin_lock_irqsave(&#38;cache_lock, flags);
         obj = __cache_find(id);
         if (obj)
-                __object_get(obj);
+                object_get(obj);
         spin_unlock_irqrestore(&#38;cache_lock, flags);
         return obj;
 }
</PRE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x338.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x378.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Accessing From Interrupt Context</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c328.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Protecting The Objects Themselves</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>