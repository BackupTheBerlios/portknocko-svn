<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Data Which Mostly Used By An IRQ Handler</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Unreliable Guide To Locking"
HREF="index.html"><LINK
REL="UP"
TITLE="Locking Speed"
HREF="c469.html"><LINK
REL="PREVIOUS"
TITLE="Per-CPU Data"
HREF="x530.html"><LINK
REL="NEXT"
TITLE="What Functions Are Safe To Call From Interrupts?"
HREF="c551.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Unreliable Guide To Locking</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x530.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 8. Locking Speed</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c551.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="mostly-hardirq"
>8.4. Data Which Mostly Used By An IRQ Handler</A
></H1
><P
>&#13;      If data is always accessed from within the same IRQ handler, you
      don't need a lock at all: the kernel already guarantees that the
      irq handler will not run simultaneously on multiple CPUs.
    </P
><P
>&#13;      Manfred Spraul points out that you can still do this, even if
      the data is very occasionally accessed in user context or
      softirqs/tasklets.  The irq handler doesn't use a lock, and
      all other accesses are done as so:
    </P
><PRE
CLASS="programlisting"
>&#13;	spin_lock(&#38;lock);
	disable_irq(irq);
	...
	enable_irq(irq);
	spin_unlock(&#38;lock);
</PRE
><P
>&#13;      The <CODE
CLASS="function"
>disable_irq()</CODE
> prevents the irq handler
      from running (and waits for it to finish if it's currently
      running on other CPUs).  The spinlock prevents any other
      accesses happening at the same time.  Naturally, this is slower
      than just a <CODE
CLASS="function"
>spin_lock_irq()</CODE
> call, so it
      only makes sense if this type of access happens extremely
      rarely.
    </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x530.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c551.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Per-CPU Data</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c469.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>What Functions Are Safe To Call From Interrupts?</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>